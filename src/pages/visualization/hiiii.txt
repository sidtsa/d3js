import React, { useMemo, useState } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, Text } from '@react-three/drei';
import * as d3 from 'd3';
import { BufferGeometry, LineBasicMaterial, Vector3 } from 'three';
import './ThreeDBarChart.css'; // Import the CSS file for positioning the popup

interface DataPoint {
  state: string;
  specialty: string;
  value: number;
  value1: string[]; // Array of strings to store multiple values
  [key: string]: any; // Allow additional properties from the CSV data
}

interface DataPointWithIndex extends DataPoint {
  index: number;
  originalData: DataPoint[]; // Add originalData to store all rows related to the bar
}

interface ThreeDBarChartProps {
  data: DataPoint[];
  colX: string;
  colY: string;
  colZ: string;
}

const ThreeDBarChart: React.FC<ThreeDBarChartProps> = ({ data, colX, colY, colZ}) => {
  const [hoveredBar, setHoveredBar] = useState<DataPointWithIndex | null>(null);
  const [isPopupOpen, setIsPopupOpen] = useState<boolean>(false);

  // Compute bar data with Z-axis values based on count of unique values in value1
  const barData = useMemo(() => {
    const groupedData = d3.rollup(
      data,
      (v) => v, // Store the full array of rows
      (d) => d.state,
      (d) => d.specialty
    );

    const flattenedData: DataPointWithIndex[] = [];
    for (const [state, specialties] of groupedData) {
      for (const [specialty, rows] of specialties) {
        const value1 = rows.map((d) => d.value1).flat(); // Flatten array of arrays
        flattenedData.push({
          state,
          specialty,
          value: 0, // Placeholder, not used
          value1,
          index: 0,
          originalData: rows as DataPoint[] // Store all rows related to this bar
        });
      }
    }
    return flattenedData;
  }, [data]);

  const sortedStates = Array.from(d3.rollup(data, (v) => d3.sum(v, (d) => d.value), (d) => d.state))
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5)
    .map((d) => d[0]);

  const topStateData = barData.filter((d) => sortedStates.includes(d.state));

  const topSpecialtiesAndValues: Record<string, { specialties: string[], values: string[] }> = {};
  sortedStates.forEach((state) => {
    const stateData = topStateData.filter((d) => d.state === state);
    const specialties = Array.from(d3.rollup(stateData, (v) => d3.sum(v, (d) => d.value), (d) => d.specialty))
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map((d) => d[0]);
    const values = Array.from(d3.rollup(stateData, (v) => d3.sum(v, (d) => d.value), (d) => d.specialty))
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map((d) => d[1]); // Use d[1] to get the values directly
    topSpecialtiesAndValues[state] = { specialties, values: values.map(String) }; // Convert values to strings
  });

  const flattenedSpecialtyData: DataPointWithIndex[] = [];
  Object.entries(topSpecialtiesAndValues).forEach(([state, { specialties }]) => {
    specialties.forEach((specialty, index) => {
      const filteredData = data.filter(d => d.state === state && d.specialty === specialty);
      const value1 = filteredData.map(d => d.value1).flat(); // Flatten array of arrays
      const uniqueValueCount = new Set(value1).size; // Count unique values
      flattenedSpecialtyData.push({
        state,
        specialty,
        value: 0,
        value1,
        index,
        originalData: filteredData // Store the original data rows associated with this bar
      });
    });
  });

  const xScale = d3.scaleBand().domain(sortedStates).range([0, sortedStates.length * 2]);
  const yScale = d3.scaleBand().domain(flattenedSpecialtyData.map((d) => d.specialty)).range([0, flattenedSpecialtyData.length * 0.5]);
  const zScale = d3.scaleLinear().domain([0, d3.max(flattenedSpecialtyData, (d) => new Set(d.value1).size) || 0]).range([0, 10]);

  const baseColors = d3.schemeCategory10;
  const lightColors = baseColors.map((color) => d3.interpolateRgb(color, '#ffffff')(0.6));
  const colorScale = d3.scaleOrdinal(lightColors);
  colorScale.domain(flattenedSpecialtyData.map(d => `${d.state}-${d.specialty}`));

  const Axis: React.FC = () => {
    const createLine = (start: [number, number, number], end: [number, number, number]) => {
      const points = [new Vector3(...start), new Vector3(...end)];
      const geometry = new BufferGeometry().setFromPoints(points);
      const material = new LineBasicMaterial({ color: 'black' });
      return (
        <line>
          <primitive object={geometry} />
          <primitive object={material} />
        </line>
      );
    };

    return (
      <>
        {createLine([0, 0, 0], [sortedStates.length * 2, 0, 0])} {/* X axis */}
        {createLine([0, 0, 0], [0, flattenedSpecialtyData.length * 0.5, 0])} {/* Y axis */}
        {createLine([0, 0, 0], [0, 0, 10])} {/* Z axis */}
      </>
    );
  };

  const AxisLabels: React.FC = () => {
    const yAxisLength = flattenedSpecialtyData.length * 0.5;
    const zAxisMaxValue = d3.max(flattenedSpecialtyData, (d) => new Set(d.value1).size) || 0;
    const zAxisTicks = d3.scaleLinear().domain([0, zAxisMaxValue]).ticks(5);
    const displayedSpecialties = new Set<string>(); // To track displayed specialties

    const labelSpacing = yAxisLength / Math.max(flattenedSpecialtyData.length, 5);

    return (
      <>
        <Text position={[sortedStates.length, -4.5, 0]} fontSize={0.5} color="black">
          {colX}
        </Text>
        <Text
          position={[-4.5, yAxisLength / 2, 0]}
          fontSize={0.5}
          color="black"
          rotation={[0, 0, Math.PI / 2]}
          anchorX="center"
          anchorY="middle"
        >
          {colY}
        </Text>
        <Text position={[-2, -1.5, 5]} rotation={[Math.PI / 2, 0, Math.PI / 2]} fontSize={0.5} color="black">
          {colZ}
        </Text>
        {sortedStates.map((state, i) => (
          <Text key={i} position={[xScale(state) || 0 + 0.5, -1.5, 0]} fontSize={0.3} color="black" rotation={[0, 0, Math.PI / 3]} anchorX="right" anchorY="middle">
            {state === '' ? 'N/A' : state}
          </Text>
        ))}
        {flattenedSpecialtyData.map((d, i) => {
          const positionY = yScale(d.specialty) || 0 + (d.index * labelSpacing);
          if (displayedSpecialties.has(d.specialty)) {
            return null; // Skip if already displayed
          }
          displayedSpecialties.add(d.specialty);
          return (
            <Text
              key={i}
              position={[-1, positionY || 0, 0]}
              fontSize={0.3}
              color="black"
              anchorX="right"
              anchorY="middle"
            >
              {d.specialty === '' ? 'N/A' : d.specialty}
            </Text>
          );
        })}
       {zAxisTicks.map((tick, i) => (
          <Text key={i} position={[-1, -1, zScale(tick) || 0]} fontSize={0.3} rotation={[Math.PI / 2, 0, 0]} color="black">
            {tick}
          </Text>
        ))}
      </>
    );
  };

  

  const Bars: React.FC = () => {
    const handleBarClick = (barData: DataPointWithIndex) => {
      setHoveredBar(barData);
      setIsPopupOpen(true);  // Open the popup
    };
    return (
      <>
       {flattenedSpecialtyData.map((d, i) => {
  const x = xScale(d.state) || 0;
  const y = yScale(d.specialty) || 0 + (d.index * yScale.bandwidth() / 3.5);
  const z = 0;
  const height = zScale(new Set(d.value1).size); // Use the unique count as height
  const color = colorScale(`${d.state}-${d.specialty}`);
  
  return (
    <mesh
      key={i}
      position={[xScale(d.state) || 0 + 0.5, yScale(d.specialty) || 0 + (d.index * 0.5) || 0 + 0.5, zScale(new Set(d.value1).size) / 2]}
      onClick={() => handleBarClick(d)}  // Pass the full data to hoveredBar on click
      // onPointerOut={() => setHoveredBar(null)}
    >
      <boxGeometry args={[1, 1, zScale(new Set(d.value1).size)]} /> {/* Dimensions of the box */}
      <meshStandardMaterial color={color} />
      <Text
        position={[0, 0, height / 2 + 0.5]} // Adjust text position to be above the bar
        fontSize={0.3}
        color="white"
        anchorX="center"
        anchorY="middle"
      >
        {new Set(d.value1).size}
      </Text>
    </mesh>
  );
})}

      </>
    );
  };

  
  const Popup: React.FC = () => {
    if (!isPopupOpen || !hoveredBar) return null;
    // if (!hoveredBar) return null;
  
    const { originalData } = hoveredBar;
  
    // Define columns to exclude
    const columnsToExclude = ['state', 'specialty', 'value', 'value1'];
  
    // Filter out the columns to exclude
    const filteredKeys = Object.keys(originalData[0]).filter(
      (key) => !columnsToExclude.includes(key)
    );

    return (
      <div className="popup">
        <div className="popup-content">
          <table>
            <thead>
              <tr>
                {filteredKeys.map((key) => (
                  <th key={key}>{key}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {originalData.map((row, index) => (
                <tr key={index}>
                  {filteredKeys.map((key) => (
                    <td key={key}>{row[key]}</td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>
    );
  };
  

  return (
<div className="chart-container" style={{ position: 'relative', height: 600 }}>
  <div className="canvas-container" style={{ width: '100%', height: '100%' }}>
    <Canvas camera={{ position: [0, 0, 20], up: [0, 0, 1] }}>
      <ambientLight intensity={0.5} />
      <pointLight position={[10, 10, 10]} />
      <OrbitControls />
      <Axis />
      <Bars />
      <AxisLabels />
    </Canvas>
    {/* {selectedPoint && <DataTable selectedData={selectedData} />} */}
  </div>
  <div className="popup-container">
    <Popup />
  </div>
</div>


  );
};

export default ThreeDBarChart;
==========================================================================

import React, { useState, useEffect } from 'react';
import * as d3 from 'd3';
import ThreeDBarChart from './ThreeDBarChart';

interface LoadCsvDataProps {
  colX: string;
  colY: string;
  colZ: string;
}

interface DataPoint {
  state: string;
  specialty: string;
  value: number;
  value1: string[]; // Or any other type based on your actual data
  [key: string]: any; // Allow any other keys to accommodate all CSV columns
}


const LoadCsvData: React.FC<LoadCsvDataProps> = ({ colX, colY, colZ }) => {
  const [data, setData] = useState<DataPoint[]>([]);

  useEffect(() => {
    d3.csv('/10000_HCP_Ven_CLL.csv').then((rawData: any[]) => {
      const processedData = rawData.map(d => {
        // Keep all columns in the data point
        return {
          ...d,
          state: d[colX],
          specialty: d[colY],
          value: +d[colZ], // Ensure this is a number
          value1: [d[colZ]] // Wrap in an array for consistency
        };
      });

      // Debugging
      console.log('Processed Data:', processedData);

      setData(processedData);
    });
  }, [colX, colY, colZ]);

  return (
    <div>
      <center>
        <h1>3-D Bar Chart</h1>
      </center>
      {data.length > 0 ? <ThreeDBarChart data={data} colX={colX} colY={colY} colZ={colZ} /> : <p>Loading data...</p>}
    </div>
  );
};

export default LoadCsvData;


=============================================
main scatter code with all values=
============================================

import React, { useState, useEffect, useMemo } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, Text } from '@react-three/drei';
import * as d3 from 'd3';
import { BufferGeometry, LineBasicMaterial, Float32BufferAttribute, Color, Vector3, Line, MeshStandardMaterial } from 'three';

// Define types for the data and props
interface DataPoint {
  x: string;
  y: string;
  z: string;
  value: number;
  [key: string]: any; // Add this line to store additional columns
}

interface AxisLabelsProps {
  cols: {
    X: string;
    Y: string;
    Z: string;
  };
  xLabels: string[];
  yLabels: string[];
  zLabels: string[];
  xScale: d3.ScaleBand<string>;
  yScale: d3.ScaleBand<string>;
  zScale: d3.ScaleBand<string>;
}

interface ThreeDScatterPlotProps {
  cols: {
    X: string;
    Y: string;
    Z: string;
  };
  extraColumn: string; // Add this to receive the extra column
}

interface PlainScatterPlotProps {
  cols: {
    X: string;
    Y: string;
    Z: string;
  };
// Add this to receive the extra column
}

// Fetch and process data
const fetchData = async ( 
  maxCount: number,
  setMaxCount: React.Dispatch<React.SetStateAction<number>>,
  setData: React.Dispatch<React.SetStateAction<DataPoint[]>>,
  cols: ThreeDScatterPlotProps['cols'],
  extraColumn: string
) => {
  const data = await d3.csv('/10000_HCP_Ven_CLL.csv');

  // Get min and max for each axis
  const xValues = data.map(d => +d[cols.X]);
  const yValues = data.map(d => +d[cols.Y]);
  const zValues = data.map(d => +d[cols.Z]);

  const xMin = Math.min(...xValues);
  const xMax = Math.max(...xValues);
  const yMin = Math.min(...yValues);
  const yMax = Math.max(...yValues);
  const zMin = Math.min(...zValues);
  const zMax = Math.max(...zValues);

  // Create ranges
  const createRanges = (min: number, max: number) => {
    const rangeSize = (max - min) / 10;
    return Array.from({ length: 10 }, (_, i) => ({
      min: min + i * rangeSize,
      max: min + (i + 1) * rangeSize,
    }));
  };

  const xRanges = createRanges(xMin, xMax);
  const yRanges = createRanges(yMin, yMax);
  const zRanges = createRanges(zMin, zMax);

  // Filter data based on ranges
  const filteredData = data.filter((d: any) => { // Explicitly define type for d
    const xValue = +d[cols.X];
    const yValue = +d[cols.Y];
    const zValue = +d[cols.Z];

    return xRanges.some(range => xValue >= range.min && xValue < range.max) &&
           yRanges.some(range => yValue >= range.min && yValue < range.max) &&
           zRanges.some(range => zValue >= range.min && zValue < range.max);
  });

  const processedData: DataPoint[] = filteredData.map(d => ({
    x: d[cols.X],
    y: d[cols.Y],
    z: d[cols.Z],
    value: 1, // or any other logic to determine value
    extraValue: d[extraColumn] || 'Unknown',
  }));

  setData(processedData);
};




// Grid component
const Grid: React.FC = () => {
  const gridSize = 10;
  const divisions = 10;
  const gridLines: number[][] = [];

  for (let i = 0; i <= divisions; i++) {
    const offset = (i / divisions) * gridSize;
    gridLines.push([offset, 0, 0, offset, gridSize, 0]); // Lines parallel to Y axis
    gridLines.push([0, offset, 0, gridSize, offset, 0]); // Lines parallel to X axis
    gridLines.push([0, 0, offset, gridSize, 0, offset]); // Lines parallel to Z axis
  }

  return (
    <>
      {gridLines.map((line, i) => {
        const points = new Float32BufferAttribute(line, 3);
        const geometry = new BufferGeometry();
        geometry.setAttribute('position', points);

        return (
          <line key={i}>
            <primitive object={geometry} />
            <lineBasicMaterial color="lightgray" />
          </line>
        );
      })}
    </>
  );
};

// Axis labels component
const AxisLabels: React.FC<AxisLabelsProps> = ({ xLabels, yLabels, zLabels, xScale, yScale, zScale, cols }) => {
  return (
    <>
      <Text position={[3.5, -3, -1]} fontSize={0.5} anchorX="center" anchorY="middle" color="black">
        {cols.X}
      </Text>
      <Text
        position={[-3.5, 3.0, -1]}
        fontSize={0.5}
        color="black"
        rotation={[0, 0, Math.PI / 2]}
        anchorX="center"
        anchorY="middle"
      >
        {cols.Y}
      </Text>
      <Text position={[-3, -1.5, 5]} rotation={[Math.PI / 2, 0, Math.PI / 2]} fontSize={0.5} color="black">
        {cols.Z}
      </Text>
      {xLabels &&
        xLabels.map((label, i) => (
          <Text key={i} position={[xScale(label) as number, -1, -1]} rotation={[0, 0, Math.PI / 3]} fontSize={0.3} color="black">
            {label}
          </Text>
        ))}
      {yLabels &&
        yLabels.map((label, i) => (
          <Text key={i} position={[-1, yScale(label) as number, -1]} fontSize={0.3} color="black" anchorX="right">
            {label}
          </Text>
        ))}
      {zLabels &&
        zLabels.map((label, i) => (
          <Text key={i} position={[-1, -1, zScale(label) as number]} fontSize={0.3} rotation={[Math.PI / 2, 0, 0]} color="black">
            {label}
          </Text>
        ))}
    </>
  );
};

// Color legend component
const ColorLegend: React.FC<{ colorScale: d3.ScaleSequential<string> }> = ({ colorScale }) => {
  if (!colorScale) return null; // Guard against null colorScale

  // Create legend data based on the range of the color scale
  const legendData = d3.range(0, 1, 0.1); // You can adjust this range as needed

  return (
    <group position={[12, 0, 5]}>
      {legendData.map((d, i) => (
        <mesh key={i} position={[0, i * 0.5, 0]}>
          <boxGeometry args={[0.5, 0.5, 0.5]} />
          <meshStandardMaterial color={colorScale(d)} />
          <Text fontSize={0.3} color="black" position={[1, 0, 0]} rotation={[0, 0, 0]}>
            {d.toFixed(1)}
          </Text>
        </mesh>
      ))}
      <Text position={[0, legendData.length * 0.5, 0]} fontSize={0.3} color="black">
        Color Legend
      </Text>
    </group>
  );
};

// Data table component
const DataTable: React.FC<{ selectedData: DataPoint[] }> = ({ selectedData }) => {
  if (selectedData.length === 0) return null;
  console.log(selectedData)
  const columns = Object.keys(selectedData[0]);

  return (
    <table style={tableStyles}>
      <thead>
        <tr>
          {columns.map(col => (
            <th key={col} style={thTdStyles}>{col}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {selectedData.map((row, rowIndex) => (
          <tr key={rowIndex}>
            {columns.map(col => (
              <td key={col} style={thTdStyles}>{row[col]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
};

const tableStyles: React.CSSProperties = {
  width: '100%',
  borderCollapse: 'collapse',
  marginTop: '20px',
  marginBottom: '20px',
  tableLayout: 'fixed',
};

const thTdStyles: React.CSSProperties = {
  border: '1px solid black',
  padding: '5px',
  textAlign: 'center',
  wordWrap: 'break-word',
};

// Main scatter plot component
const ThreeDScatterPlot: React.FC<ThreeDScatterPlotProps> = ({ cols, extraColumn }) => {
  const [data, setData] = useState<DataPoint[]>([]);
  const [maxCount, setMaxCount] = useState(0);
  const [selectedPoint, setSelectedPoint] = useState<DataPoint | null>(null);
  const [selectedData, setSelectedData] = useState<DataPoint[]>([]);

  useEffect(() => {
    fetchData(maxCount, setMaxCount, setData, cols, extraColumn);
  }, [cols.X, cols.Y, cols.Z, extraColumn]);

  // Scales for X, Y, Z axes
  const xScale = useMemo(() => (data.length > 0 ? d3.scaleBand().domain(data.map(d => d.x)).range([0, 10]) : null), [data]);
  const yScale = useMemo(() => (data.length > 0 ? d3.scaleBand().domain(data.map(d => d.y)).range([0, 10]) : null), [data]);
  const zScale = useMemo(() => (data.length > 0 ? d3.scaleBand().domain(data.map(d => d.z)).range([0, 10]) : null), [data]);

  const colorMap: { [key: string]: string } = {
    High: 'red',
    Medium: 'blue',
    Low: 'green',
    Unknown: 'gray'
  };

  const getColorForExtraColumn = (extraValue: string): string => {
    return colorMap[extraValue] || 'gray';
  };

  useEffect(() => {
    if (selectedPoint) {
      const filteredData = data.filter(
        d =>
          d.x === selectedPoint.x &&
          d.y === selectedPoint.y &&
          d.z === selectedPoint.z
      );
      setSelectedData(filteredData);
    }
  }, [selectedPoint, data]);

  if (!xScale || !yScale || !zScale) return null;

  return (
    <div style={{ height: 600 }}>
      <center>
        <h1>3-D Color Scatter Chart</h1>
      </center>
      <Canvas camera={{ position: [0, 0, 20], up: [0, 0, 1] }}>
        <ambientLight intensity={0.5} />
        <pointLight position={[20, 20, 20]} />
        <OrbitControls />

        <Grid />
        <AxisLabels xLabels={xScale.domain()} yLabels={yScale.domain()} zLabels={zScale.domain()} xScale={xScale} yScale={yScale} zScale={zScale} cols={cols} />

        {data.map((d, i) => (
          <React.Fragment key={i}>
            <mesh
              position={[xScale(d.x) as number, yScale(d.y) as number, zScale(d.z) as number]}
              onClick={() => {
                setSelectedPoint(d);
              }}
            >
              <sphereGeometry args={[0.15, 32, 32]} />
              <meshStandardMaterial color={getColorForExtraColumn(d.extraValue)} />
            </mesh>
          </React.Fragment>
        ))}
      </Canvas>

      {selectedPoint && <DataTable selectedData={selectedData} />}
    </div>
  );
};

// Fetch and process data for PlainThreeDScatterPlot
const fetchDataForPlain = async (
  maxCount: number,
  setMaxCount: React.Dispatch<React.SetStateAction<number>>,
  setData: React.Dispatch<React.SetStateAction<DataPoint[]>>,
  cols: PlainScatterPlotProps['cols']
) => {
  const data = await d3.csv('/10000_HCP_Ven_CLL.csv');
  // ... (logic for fetching and processing data without extraColumn)
};

// Plain scatter plot component
const PlainThreeDScatterPlot: React.FC<PlainScatterPlotProps> = ({ cols }) => {
  const [data, setData] = useState<DataPoint[]>([]);
  const [maxCount, setMaxCount] = useState(0);
  const [selectedPoint, setSelectedPoint] = useState<DataPoint | null>(null);
  const [selectedData, setSelectedData] = useState<DataPoint[]>([]);

  useEffect(() => {
    fetchDataForPlain(maxCount, setMaxCount, setData, cols);
  }, [cols.X, cols.Y, cols.Z]);

  const xScale = useMemo(() => (data.length > 0 ? d3.scaleBand().domain(data.map(d => d.x)).range([0, 10]) : null), [data]);
  const yScale = useMemo(() => (data.length > 0 ? d3.scaleBand().domain(data.map(d => d.y)).range([0, 10]) : null), [data]);
  const zScale = useMemo(() => (data.length > 0 ? d3.scaleBand().domain(data.map(d => d.z)).range([0, 10]) : null), [data]);

  useEffect(() => {
    if (selectedPoint) {
      const filteredData = data.filter(
        d =>
          d.x === selectedPoint.x &&
          d.y === selectedPoint.y &&
          d.z === selectedPoint.z
      );
      setSelectedData(filteredData);
    }
  }, [selectedPoint, data]);

  if (!xScale || !yScale || !zScale) return null;

  return (
    <div style={{ height: 600 }}>
      <center>
        <h1>Plain Scatter Chart</h1>
      </center>
      <Canvas camera={{ position: [0, 0, 20], up: [0, 0, 1] }}>
        <ambientLight intensity={0.5} />
        <pointLight position={[20, 20, 20]} />
        <OrbitControls />

        <Grid />
        <AxisLabels xLabels={xScale.domain()} yLabels={yScale.domain()} zLabels={zScale.domain()} xScale={xScale} yScale={yScale} zScale={zScale} cols={cols} />

        {data.map((d, i) => (
          <React.Fragment key={i}>
            <mesh
              position={[xScale(d.x) as number, yScale(d.y) as number, zScale(d.z) as number]}
              onClick={() => setSelectedPoint(d)}
            >
              <sphereGeometry args={[0.15, 32, 32]} />
              <meshStandardMaterial color="red" />
            </mesh>
            <primitive
              object={
                new Line(
                  new BufferGeometry().setFromPoints([
                    new Vector3(xScale(d.x) as number, yScale(d.y) as number, 0),
                    new Vector3(xScale(d.x) as number, yScale(d.y) as number, zScale(d.z) as number)
                  ]),
                  new LineBasicMaterial({ color: 'lightgray' })
                )
              }
            />
          </React.Fragment>
        ))}
      </Canvas>
      {selectedPoint && <DataTable selectedData={selectedData} />}
    </div>
  );
};

export { ThreeDScatterPlot, PlainThreeDScatterPlot };
